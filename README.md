# ADA_Assignment
Programming Assignments :

Unit-1: Introduction to Algorithms:Programming exercises related to implementing and analyzing the efficiency of algorithms for common tasks such as searching and sorting, analyzing the performance of different algorithms using big-O notation and empirical testing, and developing algorithms for specific problems and evaluating their efficiency and effectiveness.

C Programming Exercises:

1. Implement a binary search algorithm for an array of integers.
2. Implement a bubble sort algorithm for an array of integers.
3. Implement a selection sort algorithm for an array of integers.
4. Implement an insertion sort algorithm for an array of integers.
5. Implement a merge sort algorithm for an array of integers.
6. Implement a quick sort algorithm for an array of integers.
7. Implement a linear search algorithm for an array of integers.
8. Implement a hash table data structure using separate chaining collision resolution.
9. Implement a hash table data structure using linear probing collision resolution.
10. Implement a heap data structure and use it to sort an array of integers.
Python Programming Exercises:

1. Implement a binary search algorithm for a list of integers.
2. Implement a bubble sort algorithm for a list of integers.
3. Implement a selection sort algorithm for a list of integers.
4. Implement an insertion sort algorithm for a list of integers.
5. Implement a merge sort algorithm for a list of integers.
6. Implement a quick sort algorithm for a list of integers.
7. Implement a linear search algorithm for a list of integers.
8. Implement a hash table data structure using separate chaining collision resolution.
9. Implement a hash table data structure using linear probing collision resolution.
10. Implement a heap data structure and use it to sort a list of integers.

Flowchart Exercises:

1. Create a flowchart for a binary search algorithm.
2. Create a flowchart for a bubble sort algorithm.
3. Create a flowchart for a selection sort algorithm.4.
4. Create a flowchart for an insertion sort algorithm.
5. Create a flowchart for a merge sort algorithm.
6. Create a flowchart for a quick sort algorithm.
7. Create a flowchart for a linear search algorithm.
8. Create a flowchart for a hash table data structure using separate chaining collision resolution.
9. Create a flowchart for a hash table data structure using linear probing collision resolution.
10. Create a flowchart for a heap data structure and use it to sort an array of integers.
11. These exercises can help you practice and develop your skills in implementing and analyzing the efficiency of algorithms for common tasks such as searching and sorting, analyzing the performance of different algorithms using big-O notation and empirical testing, and developing algorithms for specific problems and evaluating their efficiency and effectiveness.

Unit-2: Divide and Conquer: Complete following programming exercises related to implementing and analyzing the efficiency of divide-and-conquer algorithms for specific problems, developing new divide-and-conquer algorithms for complex problems and evaluating their efficiency and effectiveness, and comparing and contrasting divide-and-conquer algorithms with other algorithmic approaches.

C Programming Exercises:

1. Implement a recursive algorithm for computing the factorial of a given positive integer using divide-and-conquer.
2. Implement a recursive algorithm for computing the Fibonacci sequence using divide-and-conquer.
3. Implement a recursive algorithm for computing the greatest common divisor of two integers using divide-and-conquer.
4. Implement a recursive algorithm for computing the Euclidean distance between two points in 2D space using divide-and-conquer.
5. Implement a divide-and-conquer algorithm for finding the maximum subarray sum of a given array of integers.
6. Implement a divide-and-conquer algorithm for merging two sorted arrays.
7. Implement a divide-and-conquer algorithm for finding the kth largest element in an unsorted array of integers.
8. Implement a divide-and-conquer algorithm for multiplying two large integers.
9. Implement a divide-and-conquer algorithm for finding the closest pair of points in 2D space.
10. Implement a divide-and-conquer algorithm for sorting a linked list.

Python Programming Exercises:

1. Implement a recursive algorithm for computing the factorial of a given positive integer using divide-and-conquer.
2. Implement a recursive algorithm for computing the Fibonacci sequence using divide-and-conquer.
3. Implement a recursive algorithm for computing the greatest common divisor of two integers using divide-and-conquer.
4. Implement a recursive algorithm for computing the Euclidean distance between two points in 2D space using divide-and-conquer.
5. Implement a divide-and-conquer algorithm for finding the maximum subarray sum of a given array of integers.
6. Implement a divide-and-conquer algorithm for merging two sorted arrays.
7. Implement a divide-and-conquer algorithm for finding the kth largest element in an unsorted array of integers.
8. Implement a divide-and-conquer algorithm for multiplying two large integers.
9. Implement a divide-and-conquer algorithm for finding the closest pair of points in 2D space.
10. Implement a divide-and-conquer algorithm for sorting a linked list.
11. 
Flowchart Exercises:

1. Create a flowchart for a recursive algorithm for computing the factorial of a given positive integer using divide-and-conquer.
2. Create a flowchart for a recursive algorithm for computing the Fibonacci sequence using divide-and-conquer.
3. Create a flowchart for a recursive algorithm for computing the greatest common divisor of two integers using divide-and-conquer.
4. Create a flowchart for a recursive algorithm for computing the Euclidean distance between two points in 2D space using divide-and-conquer.
5. Create a flowchart for a divide-and-conquer algorithm for finding the maximum subarray sum of a given array of integers.
6. Create a flowchart for a divide-and-conquer algorithm for merging two sorted arrays.
7. Create a flowchart for a divide-and-conquer algorithm for finding the kth largest element in an unsorted array of integers.
8. Create a flowchart for a divide-and-conquer algorithm for multiplying two large integers.
9. Create a flowchart for a divide-and-conquer algorithm for finding the closest pair of points in 2D space.
10. Create a flowchart for a divide-and-conquer algorithm for sorting a linked list.
These exercises can help you practice and develop your skills in implementing and analyzing the efficiency of divide-and-conquer algorithms for specific problems, developing new divide-and-conquer algorithms for complex problems and evaluating their efficiency and effectiveness, and comparing and contrasting divide-and-conquer algorithms with other algorithmic approaches.

Unit-3: Dynamic Programming:

C/Python /Flowchart

1. Implement the Fibonacci sequence using dynamic programming in C or Python. Analyze the time complexity of your implementation and compare it with the time complexity of a recursive implementation.
2. Implement the longest common subsequence problem using dynamic programming in C or Python. Analyze the time and space complexity of your implementation and compare it with the time and space complexity of a naive recursive implementation.
3. Implement the knapsack problem using dynamic programming in C or Python. Analyze the time and space complexity of your implementation and compare it with the time and space complexity of a greedy algorithm.
4. Implement the rod-cutting problem using dynamic programming in C or Python. Analyze the time and space complexity of your implementation and compare it with the time and space complexity of a naive recursive implementation.
5. Implement the matrix chain multiplication problem using dynamic programming in C or Python. Analyze the time and space complexity of your implementation and compare it with the time and space complexity of a naive recursive implementation.
6. Develop a dynamic programming algorithm for the edit distance problem in C or Python. Analyze the time and space complexity of your implementation and compare it with the time and space complexity of a naive recursive implementation.
7. Develop a dynamic programming algorithm for the coin change problem in C or Python. Analyze the time and space complexity of your implementation and compare it with the time and space complexity of a greedy algorithm.
8. Implement a dynamic programming algorithm to find the maximum sum subarray in C or Python. Analyze the time and space complexity of your implementation and compare it with the time and space complexity of a naive brute-force approach.
9. Develop a dynamic programming algorithm to find the longest increasing subsequence in C or Python. Analyze the time and space complexity of your implementation and compare it with the time and space complexity of a brute-force approach.
10. Create a flowchart for a dynamic programming algorithm that solves the longest common substring problem. Analyze the time and space complexity of the algorithm and compare it with the time and space complexity of a brute-force approach. These exercises will help you understand and implement dynamic programming algorithms, analyze their time and space complexity, and compare them with other algorithmic approaches.

Unit-4: Greedy Algorithms:

C/Python /Flowchart

1. Implement the Huffman coding algorithm to compress a given string in C or Python.
2. Implement Kruskal's algorithm to find the minimum spanning tree of a given graph in C or Python.
3. Implement the Dijkstra algorithm to find the shortest path between two vertices in a graph in C or Python.
4. Implement the activity selection problem using a greedy approach in C or Python.
5. Implement the knapsack problem using a greedy approach in C or Python.
6. Implement the coin change problem using a greedy approach in C or Python.
7. Develop a new greedy algorithm to solve the job scheduling problem and analyze its efficiency and effectiveness in C or Python.
8. Implement Prim's algorithm to find the minimum spanning tree of a given graph in flowchart.
9. Implement the interval scheduling problem using a greedy approach in flowchart.
10. Implement the fractional knapsack problem using a greedy approach in flowchart.

These exercises will help you practice implementing and analyzing the efficiency of greedy algorithms for specific problems, developing new greedy algorithms for complex problems, and comparing and contrasting greedy algorithms with other algorithmic approaches.

Unit-5: Graph Algorithms:

C/Python /Flowchart

1. Implement Breadth First Search (BFS) algorithm to find the shortest path between two nodes in a graph in C or Python.
2. Implement Depth First Search (DFS) algorithm to traverse a graph and find connected components in C or Python.
3. Implement Dijkstra's algorithm to find the shortest path between two nodes in a weighted graph in C or Python.
4. Implement Bellman-Ford algorithm to find the shortest path between two nodes in a graph with negative weight edges in C or Python.
5. Implement the Floyd-Warshall algorithm to find the shortest path between all pairs of nodes in a graph in C or Python.
6. Implement the Prim's algorithm to find the minimum spanning tree of a given graph in C or Python.
7. Develop a new graph algorithm to solve the traveling salesman problem and evaluate its efficiency and effectiveness in C or Python.
8. Implement the PageRank algorithm to rank web pages in a network in Python.
9. Implement the Girvan-Newman algorithm to find communities in a social network in Python.
10. Apply graph algorithms to analyze the network structure and connectivity of a real-world social network, such as Facebook or Twitter.

These exercises will help you practice implementing and analyzing the efficiency of graph algorithms for specific problems, developing new graph algorithms for complex problems, and applying graph algorithms to real-world problems such as network analysis and social network analysis.

Unit-6 :NP-Completeness:

C/Python /Flowchart

1. Implement a dynamic programming algorithm for the Longest Common Subsequence Problem (LCS), and analyze its time and space complexity using Big-O notation.
2. Develop a greedy algorithm for the Job Scheduling Problem, and evaluate its effectiveness on a variety of input instances.
3. Implement a branch and bound algorithm for the Traveling Salesman Problem, and analyze its running time complexity.
4. Develop an approximation algorithm for the Set Cover Problem, and analyze its approximation ratio and running time complexity.
5. Implement a genetic algorithm for the Knapsack Problem, and evaluate its performance on a set of large-scale instances.
6. Develop a local search algorithm for the Maximum Cut Problem, and compare its performance to that of a randomized algorithm on a set of random graphs.
7. Implement a randomized algorithm for the Vertex Cover Problem, and analyze its expected running time using probabilistic techniques.
8. Develop an approximation algorithm for the Steiner Tree Problem, and analyze its approximation ratio and running time complexity.\
9. Implement a simulated annealing algorithm for the Graph Coloring Problem, and evaluate its performance on a set of benchmark instances.
10. Develop a heuristic algorithm for the Maximum Clique Problem, and compare its performance to that of the exact algorithm on a set of benchmark instances.
11. Implement a brute force algorithm for the Traveling Salesman Problem (TSP), and analyze its time complexity using Big-O notation.
12. Develop an approximation algorithm for the Vertex Cover Problem, and evaluate its effectiveness on a variety of input graphs.
13. Implement a greedy algorithm for the Knapsack Problem, and analyze its approximation ratio.
14. Develop a heuristic algorithm for the Maximum Clique Problem, and compare its performance to that of the exact algorithm on a set of benchmark instances.
15. Implement a randomized algorithm for the Subset Sum Problem, and analyze its expected running time using probabilistic techniques.
16. Develop a genetic algorithm for the Quadratic Assignment Problem, and evaluate its performance on a set of large-scale instances.
17. Implement a local search algorithm for the Graph Coloring Problem, and compare its performance to that of a randomized algorithm on a set of randomly generated graphs.
18. Develop an approximation algorithm for the Set Cover Problem, and analyze its approximation ratio and running time comp.
19. Implement a simulated annealing algorithm for the Traveling Salesman Problem, and evaluate its performance on a set of benchmark instances.
20. Develop a tabu search algorithm for the Maximum Cut Problem, and compare its performance to that of a greedy algorithm on a set of random graphs.

Unit-7 : Advanced Topics

C/Python /Flowchart

1. Implement a parallel algorithm for matrix multiplication, and analyze its speedup and efficiency on a multicore processor or GPU.
2. Develop a randomized algorithm for the k-Median Problem, and analyze its expected running time and approximation ratio.
3. Apply a deep learning algorithm such as convolutional neural networks (CNNs) or recurrent neural networks (RNNs) to a real-world problem such as image recognition or natural language processing, and evaluate its performance on a dataset.
4. Implement a parallel algorithm for the Breadth-First Search (BFS) traversal of a graph, and analyze its speedup and efficiency on a cluster or supercomputer.
5. Develop a new algorithm for the Minimum Spanning Tree (MST) Problem, and evaluate its efficiency and effectiveness on a set of benchmark instances.
6. Apply a cryptographic algorithm such as RSA or AES to a real-world problem such as secure communication or data encryption, and analyze its security and performance.
7. Implement a parallel algorithm for the Traveling Salesman Problem, and analyze its speedup and efficiency on a distributed computing environment such as a cluster or cloud platform.\
8. Develop a new algorithm for the Maximum Flow Problem, and evaluate its efficiency and effectiveness on a set of benchmark instances.
9. Apply a bioinformatics algorithm such as Smith-Waterman or Needleman-Wunsch to a real-world problem such as DNA sequencing or protein folding, and analyze its accuracy and efficiency.\
10. Implement a randomized algorithm for the Minimum Cut Problem, and analyze its expected running time and approximation ratio.
11. For each of these exercises, it would be helpful to create a flowchart or pseudocode to help plan out the implementation before diving into the actual code. Additionally, for exercises involving real-world applications, it may be necessary to acquire or generate appropriate datasets for testing and evaluation.

Additional Assignment Compare the (serial, parallel ) algorithms implementation on (single core, multi core) processors CPU and GPU and plot the performance on various input size for following data structures:

1.Arrays
2.Linked Lists
3.Stacks
4.Queues
5.Trees
6.Hash Tables
7.Graphs
8.Heaps
9.Tries
10.Sets
11.Maps
12.Vectors
13.Matrices
14.Doubly Linked Lists
15.Priority Queues

